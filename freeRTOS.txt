void ATaskFunction(void *pvParameters)

void setup(){
// initialize ports , serial, tasks etc
Serial.begin(9600);
xTaskCreate(TaskBlink1, "my task desc", 128 (stack size),NULL, 1 (priority), NULL);
..
..
vTaskStartScheduler();
}
void loop(){} // for arduino

void TaskBlink1(void *pvParameters){
// first def vars etc

while(1){
// main loop
vTaskDelay( num_of_milli_secs / portTICK_PERIOID_MS );
}
vTaskDelete(NULL); // if ever break must delete
}



QUEUES:

#include <Arduino_FreeRTOS.h>
#include “queue.h”
QueueHandle_t queue;
int queueSize = 10;
void setup() {
Serial.begin(112500);
queue = xQueueCreate( queueSize, sizeof( int ) );
if (queue == NULL)
{
 Serial.println("Error creating the queue");
}
xTaskCreate(producerTask, /* Task function. */
 "Producer", /* String with name of task. */
 100, /* Stack size in words. */
 NULL, /* Parameter passed as input of the task */
 1, /* Priority of the task. */
 NULL); /* Task handle. */
xTaskCreate(consumerTask, /* Task function. */
 "Consumer", /* String with name of task. */
 100, /* Stack size in words. */
 NULL, /* Parameter passed as input of the task */
 1, /* Priority of the task. */
 NULL); /* Task handle. */
vTaskStartScheduler();
}
void loop() {
}
void producerTask( void * parameter )
{
 for( int i = 0; i < queueSize; i++ ){
 xQueueSend(queue, &i, portMAX_DELAY);
 }
 vTaskDelete( NULL );
}
void consumerTask( void * parameter)
{
 int element;
 for( int i = 0; i < queueSize; i++ ){
 xQueueReceive(queue, &element, portMAX_DELAY);
 Serial.print(element);
 Serial.print("|");
 }
 vTaskDelete( NULL );
}

BINARY SEMAPHORE:

 #include <Arduino_FreeRTOS.h>
#include <semphr.h> // add the FreeRTOS functions for Semaphores (or
Flags).
// Declare a mutex Semaphore Handle which we will use to manage
// the Serial Port.
// It will be used to ensure only one Task is accessing this
// resource at any time.
SemaphoreHandle_t xSerialSemaphore;
// define two Tasks for DigitalRead & AnalogRead
void TaskDigitalRead( void *pvParameters );
void TaskAnalogRead( void *pvParameters );
// the setup function runs once when you press reset or power the board
void setup()
{
 // initialize serial communication at 9600 bits per second:
 Serial.begin(9600);
 // Semaphores are useful to stop a Task proceeding, where it
 // should be paused to wait,
 // because it is sharing a resource, such as the Serial port.
 // Semaphores should only be used whilst the scheduler is
 // running, but we can set it up here.
 // Check to confirm that the Serial Semaphore has not already
 // been created.
 if ( xSerialSemaphore == NULL )
 {
 // Create a mutex semaphore we will use to manage the Serial Port
 xSerialSemaphore = xSemaphoreCreateMutex();
 if ( ( xSerialSemaphore ) != NULL )
 // Make the Serial Port available for use, by "Giving"
 // the Semaphore.
 xSemaphoreGive( ( xSerialSemaphore ) );
 }
 // Now set up two Tasks to run independently.
 xTaskCreate(
 TaskDigitalRead,
 "DigitalRead", // A name just for humans
 128, // This is the stack size
 NULL,
 2, // Priority, with 1 being the highest, and 4 the lowest.
 NULL );
 xTaskCreate(
 TaskAnalogRead,
 "AnalogRead",
 128, // Stack size
 NULL,
 1,
 NULL );
 // Now the Task scheduler, which takes over control of
 // scheduling individual Tasks, is automatically started.
 vTaskStartScheduler();
}
void loop()
{
 // Empty. Things are done in Tasks.
}
/*--------------------------------------------------*/
/*---------------------- Tasks ---------------------*/
/*--------------------------------------------------*/
void TaskDigitalRead( void *pvParameters __attribute__((unused)) ) //
This is a Task.
{
 // DigitalReadSerial
 // Reads a digital input on pin 2, prints the result to the
 // serial monitor
 // This example code is in the public domain.

 // digital pin 2 has a pushbutton attached to it. Give it a name:
 uint8_t pushButton = 2;
 // make the pushbutton's pin an input:
 pinMode(pushButton, INPUT);
 for (;;) // A Task shall never return or exit.
 {
 // read the input pin:
 int buttonState = digitalRead(pushButton);
 // See if we can obtain or "Take" the Serial Semaphore.
 // If the semaphore is not available, wait 5 ticks of the
 // Scheduler to see if it becomes free.
 if ( xSemaphoreTake( xSerialSemaphore, ( TickType_t ) 5 ) == pdTRUE
)
 {
 // We were able to obtain or "Take" the semaphore and can
 // now access the shared resource.
 // We want to have the Serial Port for us alone, as it takes
 // some time to print,
 // so we don't want it getting stolen during the middle of
 // a conversion.
 // print out the state of the button:
 Serial.println(buttonState);
 // Now free or "Give" the Serial Port for others.
 xSemaphoreGive( xSerialSemaphore );
 }
 // one tick delay (15ms) in between reads for stability
 vTaskDelay(1);
 }
}
void TaskAnalogRead( void *pvParameters __attribute__((unused)) )
{
 for (;;)
 {
 // read the input on analog pin 0:
 int sensorValue = analogRead(A0);
 // See if we can obtain or "Take" the Serial Semaphore.
 // If the semaphore is not available, wait 5 ticks of the
 // Scheduler to see if it becomes free.
 if ( xSemaphoreTake( xSerialSemaphore, ( TickType_t ) 5 ) == pdTRUE
)
 {
 // We were able to obtain or "Take" the semaphore and can
 // now access the shared resource.
 // We want to have the Serial Port for us alone, as it takes
 // some time to print,
 // so we don't want it getting stolen during the middle of
 // a conversion.
 // print out the value you read:
 Serial.println(sensorValue);
 // Now free or "Give" the Serial Port for others.
 xSemaphoreGive( xSerialSemaphore );
 }
 // one tick delay (15ms) in between reads for stability
 vTaskDelay(1);
 }
}

COUNTING SEMAPHORE:

#include <Arduino_FreeRTOS.h>
#include <semphr.h>
SemaphoreHandle_t xCountingSemaphore;
void setup()
{
 Serial.begin(9600); // Enable serial communication library.
 pinMode(LED_BUILTIN, OUTPUT);
 // Create task for Arduino led
 xTaskCreate(Task1, "Ledon", 128, NULL, 0 , NULL );

 xTaskCreate(Task2, "Ledoff", 128, NULL, 0, NULL );
 xCountingSemaphore = xSemaphoreCreateCounting(1,1);
 xSemaphoreGive(xCountingSemaphore);
 vTaskStartScheduler();
}
void loop() {}
void Task1(void *pvParameters)
{
 (void) pvParameters;
 for (;;)
 {
 xSemaphoreTake(xCountingSemaphore, portMAX_DELAY);
 Serial.println("Inside Task1 and Serial monitor Resource Taken");
 digitalWrite(LED_BUILTIN, HIGH);
 xSemaphoreGive(xCountingSemaphore);
 vTaskDelay(1);
 }
}
void Task2(void *pvParameters)
{
 (void) pvParameters;
 for (;;)
 {
 xSemaphoreTake(xCountingSemaphore, portMAX_DELAY);
 Serial.println("Inside Task2 and Serial monitor Resource Taken");
 digitalWrite(LED_BUILTIN, LOW);
 xSemaphoreGive(xCountingSemaphore);
 vTaskDelay(1);
 }
}
